
-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Create Table: videos
create table public.videos (
  id uuid default gen_random_uuid() primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  -- Link to Auth User
  user_id uuid references auth.users not null,

  -- The original filename or project name
  title text,
  
  -- URLs to the files in the 'uploads' bucket
  input_video_url text not null,
  final_video_url text,
  
  -- Processing status
  status text default 'processing' check (status in ('processing', 'completed', 'failed')),
  
  -- Store metadata used for generation
  voice_id text,
  crop_data jsonb, -- {x, y, width, height}
  trim_data jsonb, -- {start, end}
  
  -- Store the Gemini Analysis result
  analysis_result jsonb
);

-- PROFILES TABLE (Credits & Payment Info)
create table public.profiles (
  id uuid references auth.users on delete cascade primary key,
  credits integer default 0,
  dodo_customer_id text,
  billing_address jsonb,
  last_payment_currency text,
  card_last_four text,
  phone_number text,
  customer_email text,
  customer_name text,
  updated_at timestamp with time zone
);

-- Credit Transactions Log (Optional but recommended)
create table public.credit_transactions (
  id uuid default gen_random_uuid() primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  user_id uuid references auth.users not null,
  amount integer not null,
  type text check (type in ('purchase', 'usage', 'adjustment', 'failed')),
  description text,
  metadata jsonb
);

-- Enable RLS
alter table public.videos enable row level security;
alter table public.profiles enable row level security;
alter table public.credit_transactions enable row level security;

-- Policies
-- Videos
create policy "Users can view own videos" on public.videos
    for select using (auth.uid() = user_id);
create policy "Users can insert own videos" on public.videos
    for insert with check (auth.uid() = user_id);
create policy "Users can update own videos" on public.videos
    for update using (auth.uid() = user_id);
create policy "Users can delete own videos" on public.videos
    for delete using (auth.uid() = user_id);

-- Profiles
create policy "Users can view own profile" on public.profiles
    for select using (auth.uid() = id);
    
-- Credit Transactions
create policy "Users can view own transactions" on public.credit_transactions
    for select using (auth.uid() = user_id);


-- Storage Bucket Setup
insert into storage.buckets (id, name, public) 
values ('uploads', 'uploads', true)
on conflict (id) do nothing;

-- Policies for storage.objects (Authenticated Access for 'uploads' bucket)
create policy "Authenticated users can upload to uploads"
on storage.objects for insert
to authenticated
with check (bucket_id = 'uploads');

create policy "Authenticated users can read from uploads"
on storage.objects for select
to authenticated
using (bucket_id = 'uploads');

create policy "Authenticated users can update in uploads"
on storage.objects for update
to authenticated
using (bucket_id = 'uploads');

create policy "Authenticated users can delete from uploads"
on storage.objects for delete
to authenticated
using (bucket_id = 'uploads');


-- FUNCTIONS & TRIGGERS
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, credits)
  values (new.id, 0); 
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

create or replace function grant_credits_from_purchase(
  p_user_id uuid,
  p_credits_to_add int,
  p_description text,
  p_metadata jsonb
)
returns void
language plpgsql
security definer
as $$
declare
  purchase_count int;
  bonus_credits int;
  total_to_add int;
begin
  -- Count previous successful purchases
  select count(*) into purchase_count 
  from public.credit_transactions 
  where user_id = p_user_id and type = 'purchase';

  -- Logic: First purchase gets +2 bonus, subsequent get +1 bonus
  if purchase_count = 0 then
    bonus_credits := 2;
  else
    bonus_credits := 1;
  end if;

  total_to_add := p_credits_to_add + bonus_credits;

  update public.profiles
  set credits = credits + total_to_add,
      updated_at = now()
  where id = p_user_id;

  insert into public.credit_transactions (user_id, amount, type, description, metadata)
  values (p_user_id, total_to_add, 'purchase', p_description || ' (incl. ' || bonus_credits || ' bonus)', p_metadata);
end;
$$;

create or replace function charge_credit(
  p_user_id uuid
)
returns void
language plpgsql
security definer
as $$
declare
  current_credits int;
begin
  select credits into current_credits from public.profiles where id = p_user_id;
  
  if current_credits is null or current_credits < 1 then
    raise exception 'Insufficient credits';
  end if;

  update public.profiles
  set credits = credits - 1,
      updated_at = now()
  where id = p_user_id;
  
  insert into public.credit_transactions (user_id, amount, type, description)
  values (p_user_id, -1, 'usage', 'Video Generation');
end;
$$;